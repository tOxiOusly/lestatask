# Пояснения к заданиям

# Задание 1
Аналогичная по функциональности функция isEven - в ней операция взятия остатка заменена на проверку последнего бита числа. Если он 0, то чётное, т.к. в 
двоичном представлении чётные оканчиваются на 0
Плюс: более производительная, так как используется битовая операция, а не взятие остатка
Минус: просто менее читаема в коде

# Задача 2
Я реализовал циклический буфер FIFO (первый зашел первый вышел) двумя способами: при помощи просто List и при помощи collections.deque 
Я сравню две эти реализации между собой, выделю так же плюсы и минусы 

                                          List                     |              Deque
Гибкость                        Можно адаптировать под себя,       |   Более ограниченный функционал,
                                добавляя различный фунционал.      |   так как завязан на коллекции
                                Я, например, реализовал функцию    |
                                front - она позволяет смотреть     |
                                на первый элемент буфера, не       |
                                удаляя его                         |
                                                                   |
                                                                   |
Производительность              Медленнее, так как реализован      |  Быстрее, реализован на C
                                полностью на Python                |
                                                                   |
                                                                   |
Сложность реализации           Больше кода, так как сам            |  Встроенная коллкекция позволяет
                               простраиваешь логику функций        |  всё коротко и лаконично писать


# Задача 3
Самый быстрый способ отсортировать рандомный массив - это использовать сортировку, специально созданную для Python - Timsort
Она представляет собой гибрид Merge Sort и Insertion Sort. Основное его преимущество перед другими: он ищет уже отсортированные подпоследовательности
и не сортирует их заново. Благодаря этому он выигрывает на отсортированных и почти отсортированных данных у других алгоритмов
В коде я представил сравнение разных популярных алгоритмов сортировки для доказательства. В качестве данных я использовал рандомно сгенерированный 
массив и упорядоченный массив. Timsort имеет гигантский отрыв во втором случае.
