# Пояснения к заданиям

# Задание 1
Аналогичная по функциональности функция isEven - в ней операция взятия остатка заменена на проверку последнего бита числа. Если он 0, то чётное, т.к. в 
двоичном представлении чётные оканчиваются на 0
Плюс: более производительная, так как используется битовая операция, а не взятие остатка
Минус: просто менее читаема в коде

# Задача 2
Я реализовал циклический буфер FIFO (первый зашел первый вышел) двумя способами: при помощи просто List и при помощи collections.deque 
Я сравню две эти реализации между собой, выделю так же плюсы и минусы 

| Критерий | List | Deque |
|-----------|------|-------|
| **Гибкость** | Можно адаптировать под себя,<br>добавляя различный функционал.<br>Например, я реализовал `front()` — она позволяет<br>смотреть на первый элемент буфера, не удаляя его. | Более ограниченный функционал,<br>так как завязан на коллекции. |
| **Производительность** | Медленнее, так как реализован полностью на Python. | Быстрее, так как реализован на C. |
| **Сложность реализации** | Требует больше кода, потому что ты сам<br>строишь всю логику функций. | Встроенная коллекция позволяет<br>всё писать коротко и лаконично. |



# Задача 3
Самый быстрый способ отсортировать рандомный массив - это использовать сортировку, специально созданную для Python - Timsort
Она представляет собой гибрид Merge Sort и Insertion Sort. Основное его преимущество перед другими: он ищет уже отсортированные подпоследовательности
и не сортирует их заново. Благодаря этому он выигрывает на отсортированных и почти отсортированных данных у других алгоритмов
В коде я представил сравнение разных популярных алгоритмов сортировки для доказательства. В качестве данных я использовал рандомно сгенерированный 
массив и упорядоченный массив. Timsort имеет гигантский отрыв во втором случае.
